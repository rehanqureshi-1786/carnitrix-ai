import fs from 'fs';
import path from 'path';
import chalk from 'chalk';

/**
 * Exploit simulation engine - SAFE, NON-DESTRUCTIVE
 * Analyzes code for dangerous patterns and simulates theoretical impact
 */

export interface ExploitPattern {
    pattern: RegExp;
    name: string;
    severity: number; // 0-10
    category: string;
    description: string;
    impact: string;
}

export interface ExploitSimulationResult {
    file: string;
    threats: Array<{
        pattern: string;
        line: number;
        severity: number;
        category: string;
        impact: string;
        code: string;
    }>;
    overallSeverity: number;
    exploitable: boolean;
}

export class ExploitSimulator {
    /**
     * Dangerous code patterns to detect
     */
    private static patterns: ExploitPattern[] = [
        {
            pattern: /gets\s*\(/g,
            name: 'Buffer Overflow (gets)',
            severity: 10,
            category: 'Memory Corruption',
            description: 'Unbounded buffer read - classic stack overflow',
            impact: 'Control flow hijack, arbitrary code execution'
        },
        {
            pattern: /strcpy\s*\(/g,
            name: 'Unsafe String Copy',
            severity: 9,
            category: 'Memory Corruption',
            description: 'No bounds checking on string copy',
            impact: 'Buffer overflow, potential code execution'
        },
        {
            pattern: /eval\s*\(/g,
            name: 'Code Injection (eval)',
            severity: 9,
            category: 'Code Injection',
            description: 'Dynamic code execution from untrusted input',
            impact: 'Arbitrary code execution, system compromise'
        },
        {
            pattern: /exec\s*\(/g,
            name: 'Command Injection',
            severity: 8,
            category: 'Command Injection',
            description: 'Shell command execution with potential user input',
            impact: 'System command execution, privilege escalation'
        },
        {
            pattern: /system\s*\(/g,
            name: 'System Call Injection',
            severity: 8,
            category: 'Command Injection',
            description: 'Direct system call execution',
            impact: 'Operating system command execution'
        },
        {
            pattern: /innerHTML\s*=/g,
            name: 'XSS Vulnerability',
            severity: 7,
            category: 'Cross-Site Scripting',
            description: 'Direct HTML injection without sanitization',
            impact: 'Client-side code execution, session hijacking'
        },
        {
            pattern: /dangerouslySetInnerHTML/g,
            name: 'React XSS Risk',
            severity: 7,
            category: 'Cross-Site Scripting',
            description: 'Bypassing React XSS protection',
            impact: 'DOM-based XSS, client compromise'
        },
        {
            pattern: /SELECT\s+.*\s+FROM\s+.*\s+WHERE\s+.*\+/gi,
            name: 'SQL Injection',
            severity: 9,
            category: 'Injection Attack',
            description: 'String concatenation in SQL query',
            impact: 'Database compromise, data exfiltration'
        }
    ];

    /**
     * Analyze file for exploit patterns
     */
    static async analyze(filePath: string): Promise<ExploitSimulationResult> {
        if (!fs.existsSync(filePath)) {
            throw new Error(`File not found: ${filePath}`);
        }

        const content = fs.readFileSync(filePath, 'utf-8');
        const lines = content.split('\n');
        const threats: ExploitSimulationResult['threats'] = [];

        // Scan for patterns
        for (const pattern of this.patterns) {
            lines.forEach((line, index) => {
                if (pattern.pattern.test(line)) {
                    threats.push({
                        pattern: pattern.name,
                        line: index + 1,
                        severity: pattern.severity,
                        category: pattern.category,
                        impact: pattern.impact,
                        code: line.trim()
                    });
                }
            });
        }

        const overallSeverity = threats.length > 0
            ? Math.max(...threats.map(t => t.severity))
            : 0;

        return {
            file: filePath,
            threats,
            overallSeverity,
            exploitable: overallSeverity >= 7
        };
    }

    /**
     * Simulate exploit impact (SAFE - no actual execution)
     */
    static async simulateImpact(result: ExploitSimulationResult): Promise<string[]> {
        const simulation: string[] = [];

        simulation.push(chalk.red.bold('\n═══════════════════════════════════════════════════'));
        simulation.push(chalk.red.bold('   EXPLOIT SIMULATION - THEORETICAL ANALYSIS ONLY'));
        simulation.push(chalk.red.bold('═══════════════════════════════════════════════════\n'));

        if (result.threats.length === 0) {
            simulation.push(chalk.green('✓ No exploitable patterns detected'));
            simulation.push(chalk.green('  System appears secure from common attack vectors\n'));
            return simulation;
        }

        simulation.push(chalk.yellow(`⚠ ${result.threats.length} potential threat(s) identified\n`));

        for (const threat of result.threats) {
            simulation.push(chalk.red(`┌─ ${threat.pattern}`));
            simulation.push(chalk.white(`│  Location: Line ${threat.line}`));
            simulation.push(chalk.white(`│  Category: ${threat.category}`));
            simulation.push(chalk.white(`│  Severity: ${this.getSeverityBar(threat.severity)}`));
            simulation.push(chalk.dim(`│  Code: ${threat.code}`));
            simulation.push(chalk.yellow(`│  Impact: ${threat.impact}`));
            simulation.push(chalk.red(`└─ Exploitability: ${threat.severity >= 8 ? 'CRITICAL' : 'HIGH'}\n`));
        }

        // Simulated attack trace
        if (result.overallSeverity >= 8) {
            simulation.push(chalk.red.bold('\n⚠ SIMULATING ATTACK VECTOR:\n'));
            simulation.push(chalk.dim('  [1] Attacker crafts malicious payload'));
            simulation.push(chalk.dim('  [2] Payload exceeds buffer boundary'));
            simulation.push(chalk.dim('  [3] Stack frame corruption detected'));
            simulation.push(chalk.dim('  [4] Return address overwritten'));
            simulation.push(chalk.red('  [5] Control flow hijack - CRITICAL\n'));

            // CRITICAL: Add dramatic pause before impact message
            await new Promise(resolve => setTimeout(resolve, 700));

            // High-impact boxed section
            simulation.push(chalk.red.bold('  ╔══════════════════════════════════════╗'));
            simulation.push(chalk.red.bold('  ║     CRITICAL THREAT LEVEL            ║'));
            simulation.push(chalk.red.bold(`  ║     ${result.overallSeverity.toFixed(1)} / 10                           ║`));
            simulation.push(chalk.red.bold('  ╚══════════════════════════════════════╝\n'));
            simulation.push(chalk.red.bold('  ⚠ EXPLOITATION HIGHLY PROBABLE\n'));
        }

        return simulation;
    }

    /**
     * Visual severity bar
     */
    private static getSeverityBar(severity: number): string {
        const filled = Math.floor(severity);
        const empty = 10 - filled;
        const bar = chalk.red('█'.repeat(filled)) + chalk.gray('░'.repeat(empty));
        return `${bar} ${severity.toFixed(1)}/10`;
    }
}
